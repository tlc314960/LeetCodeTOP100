好长时间不写二叉树的递归题目，碰到又不会了。看题解稍后写感想。
这题的递归有些奇怪，由于要判断是否为二叉搜索树，而二叉搜索树的条件又是左边的都小于root，右边的都大于root，所以左右子树都有一个范围，分别是（小于root和大于root），这个就构成递归的参数条件，每次递归传入root和left和right范围。当然第一次左右是任意数，这里就涉及到了一种用null（参数就要用Integer left，Integer right）和使用long的MaxValue和MinValue。两种中后面的比较简单，推荐使用后面一种。

还有一种采用中序遍历的方法。这种方法很巧妙，利用了二叉搜索树的中序遍历性质，即其中序遍历所得的数字序列一定是严格递增的。那么我们即可在中序遍历的递归中，保存当前root的值到一个变量中供下一次递归比较使用。pre的初始值设为long minvalue这样在到整个树最左边一个节点的时候root value是一定大于pre的，可以保证程序的正常运行（比较完这个最左边的节点后，pre的值就会变成这个节点的value，然后去看这个节点的右边子树）。